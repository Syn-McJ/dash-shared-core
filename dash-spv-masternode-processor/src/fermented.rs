# [allow (clippy :: let_and_return , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables)] pub mod types { pub mod chain { pub mod common { pub mod llmq_type { use crate :: chain :: common :: llmq_type :: LLMQType ; use crate :: chain :: common :: llmq_type :: LLMQParams ; use crate :: chain :: common :: llmq_type :: DKGParams ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the DKGParams\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct DKGParams_FFI { pub interval : u32 , pub phase_blocks : u32 , pub mining_window_start : u32 , pub mining_window_end : u32 , pub bad_votes_threshold : u32 , } impl ferment_interfaces :: FFIConversion < DKGParams > for DKGParams_FFI { unsafe fn ffi_from_const (ffi : * const DKGParams_FFI) -> DKGParams { let ffi_ref = & * ffi ; DKGParams { interval : ffi_ref . interval , phase_blocks : ffi_ref . phase_blocks , mining_window_start : ffi_ref . mining_window_start , mining_window_end : ffi_ref . mining_window_end , bad_votes_threshold : ffi_ref . bad_votes_threshold , } } unsafe fn ffi_to_const (obj : DKGParams) -> * const DKGParams_FFI { ferment_interfaces :: boxed (DKGParams_FFI { interval : obj . interval , phase_blocks : obj . phase_blocks , mining_window_start : obj . mining_window_start , mining_window_end : obj . mining_window_end , bad_votes_threshold : obj . bad_votes_threshold , }) } unsafe fn destroy (ffi : * mut DKGParams_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for DKGParams_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; { } ; { } ; { } ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DKGParams_FFI_destroy (ffi : * mut DKGParams_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the LLMQType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum LLMQType_FFI { LlmqtypeUnknown = 0 , Llmqtype50_60 = 1 , Llmqtype400_60 = 2 , Llmqtype400_85 = 3 , Llmqtype100_67 = 4 , Llmqtype60_75 = 5 , Llmqtype25_67 = 6 , LlmqtypeTest = 100 , LlmqtypeDevnet = 101 , LlmqtypeTestV17 = 102 , LlmqtypeTestDIP0024 = 103 , LlmqtypeTestInstantSend = 104 , LlmqtypeDevnetDIP0024 = 105 , LlmqtypeTestnetPlatform = 106 , LlmqtypeDevnetPlatform = 107 , } impl ferment_interfaces :: FFIConversion < LLMQType > for LLMQType_FFI { unsafe fn ffi_from_const (ffi : * const LLMQType_FFI) -> LLMQType { let ffi_ref = & * ffi ; match ffi_ref { LLMQType_FFI :: LlmqtypeUnknown => LLMQType :: LlmqtypeUnknown , LLMQType_FFI :: Llmqtype50_60 => LLMQType :: Llmqtype50_60 , LLMQType_FFI :: Llmqtype400_60 => LLMQType :: Llmqtype400_60 , LLMQType_FFI :: Llmqtype400_85 => LLMQType :: Llmqtype400_85 , LLMQType_FFI :: Llmqtype100_67 => LLMQType :: Llmqtype100_67 , LLMQType_FFI :: Llmqtype60_75 => LLMQType :: Llmqtype60_75 , LLMQType_FFI :: Llmqtype25_67 => LLMQType :: Llmqtype25_67 , LLMQType_FFI :: LlmqtypeTest => LLMQType :: LlmqtypeTest , LLMQType_FFI :: LlmqtypeDevnet => LLMQType :: LlmqtypeDevnet , LLMQType_FFI :: LlmqtypeTestV17 => LLMQType :: LlmqtypeTestV17 , LLMQType_FFI :: LlmqtypeTestDIP0024 => LLMQType :: LlmqtypeTestDIP0024 , LLMQType_FFI :: LlmqtypeTestInstantSend => LLMQType :: LlmqtypeTestInstantSend , LLMQType_FFI :: LlmqtypeDevnetDIP0024 => LLMQType :: LlmqtypeDevnetDIP0024 , LLMQType_FFI :: LlmqtypeTestnetPlatform => LLMQType :: LlmqtypeTestnetPlatform , LLMQType_FFI :: LlmqtypeDevnetPlatform => LLMQType :: LlmqtypeDevnetPlatform , } } unsafe fn ffi_to_const (obj : LLMQType) -> * const LLMQType_FFI { ferment_interfaces :: boxed (match obj { LLMQType :: LlmqtypeUnknown => LLMQType_FFI :: LlmqtypeUnknown , LLMQType :: Llmqtype50_60 => LLMQType_FFI :: Llmqtype50_60 , LLMQType :: Llmqtype400_60 => LLMQType_FFI :: Llmqtype400_60 , LLMQType :: Llmqtype400_85 => LLMQType_FFI :: Llmqtype400_85 , LLMQType :: Llmqtype100_67 => LLMQType_FFI :: Llmqtype100_67 , LLMQType :: Llmqtype60_75 => LLMQType_FFI :: Llmqtype60_75 , LLMQType :: Llmqtype25_67 => LLMQType_FFI :: Llmqtype25_67 , LLMQType :: LlmqtypeTest => LLMQType_FFI :: LlmqtypeTest , LLMQType :: LlmqtypeDevnet => LLMQType_FFI :: LlmqtypeDevnet , LLMQType :: LlmqtypeTestV17 => LLMQType_FFI :: LlmqtypeTestV17 , LLMQType :: LlmqtypeTestDIP0024 => LLMQType_FFI :: LlmqtypeTestDIP0024 , LLMQType :: LlmqtypeTestInstantSend => LLMQType_FFI :: LlmqtypeTestInstantSend , LLMQType :: LlmqtypeDevnetDIP0024 => LLMQType_FFI :: LlmqtypeDevnetDIP0024 , LLMQType :: LlmqtypeTestnetPlatform => LLMQType_FFI :: LlmqtypeTestnetPlatform , LLMQType :: LlmqtypeDevnetPlatform => LLMQType_FFI :: LlmqtypeDevnetPlatform , }) } unsafe fn destroy (ffi : * mut LLMQType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQType_FFI { fn drop (& mut self) { unsafe { match self { LLMQType_FFI :: LlmqtypeUnknown => { } , LLMQType_FFI :: Llmqtype50_60 => { } , LLMQType_FFI :: Llmqtype400_60 => { } , LLMQType_FFI :: Llmqtype400_85 => { } , LLMQType_FFI :: Llmqtype100_67 => { } , LLMQType_FFI :: Llmqtype60_75 => { } , LLMQType_FFI :: Llmqtype25_67 => { } , LLMQType_FFI :: LlmqtypeTest => { } , LLMQType_FFI :: LlmqtypeDevnet => { } , LLMQType_FFI :: LlmqtypeTestV17 => { } , LLMQType_FFI :: LlmqtypeTestDIP0024 => { } , LLMQType_FFI :: LlmqtypeTestInstantSend => { } , LLMQType_FFI :: LlmqtypeDevnetDIP0024 => { } , LLMQType_FFI :: LlmqtypeTestnetPlatform => { } , LLMQType_FFI :: LlmqtypeDevnetPlatform => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQType_FFI_destroy (ffi : * mut LLMQType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the LLMQParams\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct LLMQParams_FFI { pub r#type : * mut LLMQType_FFI , pub name : * mut std :: os :: raw :: c_char , pub size : u32 , pub min_size : u32 , pub threshold : u32 , pub dkg_params : * mut DKGParams_FFI , pub signing_active_quorum_count : u32 , pub keep_old_connections : u32 , pub recovery_members : u32 , } impl ferment_interfaces :: FFIConversion < LLMQParams > for LLMQParams_FFI { unsafe fn ffi_from_const (ffi : * const LLMQParams_FFI) -> LLMQParams { let ffi_ref = & * ffi ; LLMQParams { r#type : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . r#type) , name : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . name) , size : ffi_ref . size , min_size : ffi_ref . min_size , threshold : ffi_ref . threshold , dkg_params : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . dkg_params) , signing_active_quorum_count : ffi_ref . signing_active_quorum_count , keep_old_connections : ffi_ref . keep_old_connections , recovery_members : ffi_ref . recovery_members , } } unsafe fn ffi_to_const (obj : LLMQParams) -> * const LLMQParams_FFI { ferment_interfaces :: boxed (LLMQParams_FFI { r#type : ferment_interfaces :: FFIConversion :: ffi_to (obj . r#type) , name : ferment_interfaces :: FFIConversion :: ffi_to (obj . name) , size : obj . size , min_size : obj . min_size , threshold : obj . threshold , dkg_params : ferment_interfaces :: FFIConversion :: ffi_to (obj . dkg_params) , signing_active_quorum_count : obj . signing_active_quorum_count , keep_old_connections : obj . keep_old_connections , recovery_members : obj . recovery_members , }) } unsafe fn destroy (ffi : * mut LLMQParams_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQParams_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < LLMQType_FFI as ferment_interfaces :: FFIConversion < LLMQType >> :: destroy (ffi_ref . r#type) ; < std :: os :: raw :: c_char as ferment_interfaces :: FFIConversion < & str >> :: destroy (ffi_ref . name) ; { } ; { } ; { } ; < DKGParams_FFI as ferment_interfaces :: FFIConversion < DKGParams >> :: destroy (ffi_ref . dkg_params) ; { } ; { } ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQParams_FFI_destroy (ffi : * mut LLMQParams_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod chain_type { use crate :: chain :: common :: llmq_type :: LLMQType ; use crate :: chain :: common :: chain_type :: IHaveChainSettings ; use crate :: crypto :: UInt256 ; use crate :: chain :: common :: chain_type :: DevnetType ; use crate :: chain :: common :: chain_type :: ChainType ; use crate :: fermented :: types :: chain :: common :: llmq_type :: LLMQType_FFI ; # [doc = "FFI-representation of the DevnetType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum DevnetType_FFI { JackDaniels = 0 , Devnet333 = 1 , Chacha = 2 , Mojito = 3 , WhiteRussian = 4 , MiningTest = 5 , Mobile2 = 6 , Zero = 7 , Screwdriver = 8 , Absinthe = 9 , Bintang = 10 , } impl ferment_interfaces :: FFIConversion < DevnetType > for DevnetType_FFI { unsafe fn ffi_from_const (ffi : * const DevnetType_FFI) -> DevnetType { let ffi_ref = & * ffi ; match ffi_ref { DevnetType_FFI :: JackDaniels => DevnetType :: JackDaniels , DevnetType_FFI :: Devnet333 => DevnetType :: Devnet333 , DevnetType_FFI :: Chacha => DevnetType :: Chacha , DevnetType_FFI :: Mojito => DevnetType :: Mojito , DevnetType_FFI :: WhiteRussian => DevnetType :: WhiteRussian , DevnetType_FFI :: MiningTest => DevnetType :: MiningTest , DevnetType_FFI :: Mobile2 => DevnetType :: Mobile2 , DevnetType_FFI :: Zero => DevnetType :: Zero , DevnetType_FFI :: Screwdriver => DevnetType :: Screwdriver , DevnetType_FFI :: Absinthe => DevnetType :: Absinthe , DevnetType_FFI :: Bintang => DevnetType :: Bintang , } } unsafe fn ffi_to_const (obj : DevnetType) -> * const DevnetType_FFI { ferment_interfaces :: boxed (match obj { DevnetType :: JackDaniels => DevnetType_FFI :: JackDaniels , DevnetType :: Devnet333 => DevnetType_FFI :: Devnet333 , DevnetType :: Chacha => DevnetType_FFI :: Chacha , DevnetType :: Mojito => DevnetType_FFI :: Mojito , DevnetType :: WhiteRussian => DevnetType_FFI :: WhiteRussian , DevnetType :: MiningTest => DevnetType_FFI :: MiningTest , DevnetType :: Mobile2 => DevnetType_FFI :: Mobile2 , DevnetType :: Zero => DevnetType_FFI :: Zero , DevnetType :: Screwdriver => DevnetType_FFI :: Screwdriver , DevnetType :: Absinthe => DevnetType_FFI :: Absinthe , DevnetType :: Bintang => DevnetType_FFI :: Bintang , }) } unsafe fn destroy (ffi : * mut DevnetType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for DevnetType_FFI { fn drop (& mut self) { unsafe { match self { DevnetType_FFI :: JackDaniels => { } , DevnetType_FFI :: Devnet333 => { } , DevnetType_FFI :: Chacha => { } , DevnetType_FFI :: Mojito => { } , DevnetType_FFI :: WhiteRussian => { } , DevnetType_FFI :: MiningTest => { } , DevnetType_FFI :: Mobile2 => { } , DevnetType_FFI :: Zero => { } , DevnetType_FFI :: Screwdriver => { } , DevnetType_FFI :: Absinthe => { } , DevnetType_FFI :: Bintang => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DevnetType_FFI_destroy (ffi : * mut DevnetType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [allow (non_snake_case , non_upper_case_globals)] static DevnetType_IHaveChainSettings_VTable : IHaveChainSettings_VTable = { unsafe extern "C" fn DevnetType_genesis_hash (obj : * const () ,) -> * mut [u8 ; 32] { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . genesis_hash () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_genesis_height (obj : * const () ,) -> u32 { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . genesis_height () ; obj } unsafe extern "C" fn DevnetType_is_llmq_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . is_llmq_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_isd_llmq_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . isd_llmq_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_chain_locks_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . chain_locks_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_platform_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . platform_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn DevnetType_should_process_llmq_of_type (obj : * const () , llmq_type : * mut LLMQType_FFI ,) -> bool { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . should_process_llmq_of_type (ferment_interfaces :: FFIConversion :: ffi_from (llmq_type) ,) ; obj } unsafe extern "C" fn DevnetType_is_evolution_enabled (obj : * const () ,) -> bool { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . is_evolution_enabled () ; obj } unsafe extern "C" fn DevnetType_name (obj : * const () ,) -> * mut std :: os :: raw :: c_char { let cast_obj = & (* (obj as * const DevnetType)) ; let obj = cast_obj . name () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } IHaveChainSettings_VTable { genesis_hash : DevnetType_genesis_hash , genesis_height : DevnetType_genesis_height , is_llmq_type : DevnetType_is_llmq_type , isd_llmq_type : DevnetType_isd_llmq_type , chain_locks_type : DevnetType_chain_locks_type , platform_type : DevnetType_platform_type , should_process_llmq_of_type : DevnetType_should_process_llmq_of_type , is_evolution_enabled : DevnetType_is_evolution_enabled , name : DevnetType_name , } } ; # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub extern "C" fn DevnetType_as_IHaveChainSettings_TraitObject (obj : * const DevnetType) -> IHaveChainSettings_TraitObject { IHaveChainSettings_TraitObject { object : obj as * const () , vtable : & DevnetType_IHaveChainSettings_VTable , } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn DevnetType_as_IHaveChainSettings_TraitObject_destroy (obj : IHaveChainSettings_TraitObject) { ferment_interfaces :: unbox_any (obj . object as * mut DevnetType) ; } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IHaveChainSettings_VTable { pub genesis_hash : unsafe extern "C" fn (obj : * const () ,) -> * mut [u8 ; 32] , pub genesis_height : unsafe extern "C" fn (obj : * const () ,) -> u32 , pub is_llmq_type : unsafe extern "C" fn (obj : * const () ,) -> * mut LLMQType_FFI , pub isd_llmq_type : unsafe extern "C" fn (obj : * const () ,) -> * mut LLMQType_FFI , pub chain_locks_type : unsafe extern "C" fn (obj : * const () ,) -> * mut LLMQType_FFI , pub platform_type : unsafe extern "C" fn (obj : * const () ,) -> * mut LLMQType_FFI , pub should_process_llmq_of_type : unsafe extern "C" fn (obj : * const () , llmq_type : * mut LLMQType_FFI ,) -> bool , pub is_evolution_enabled : unsafe extern "C" fn (obj : * const () ,) -> bool , pub name : unsafe extern "C" fn (obj : * const () ,) -> * mut std :: os :: raw :: c_char , } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct IHaveChainSettings_TraitObject { pub object : * const () , pub vtable : * const IHaveChainSettings_VTable , } # [doc = "FFI-representation of the ChainType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum ChainType_FFI { MainNet , TestNet , DevNet (* mut DevnetType_FFI ,) , } impl ferment_interfaces :: FFIConversion < ChainType > for ChainType_FFI { unsafe fn ffi_from_const (ffi : * const ChainType_FFI) -> ChainType { let ffi_ref = & * ffi ; match ffi_ref { ChainType_FFI :: MainNet => ChainType :: MainNet , ChainType_FFI :: TestNet => ChainType :: TestNet , ChainType_FFI :: DevNet (o_0 ,) => ChainType :: DevNet (ferment_interfaces :: FFIConversion :: ffi_from (* o_0) ,) , } } unsafe fn ffi_to_const (obj : ChainType) -> * const ChainType_FFI { ferment_interfaces :: boxed (match obj { ChainType :: MainNet => ChainType_FFI :: MainNet , ChainType :: TestNet => ChainType_FFI :: TestNet , ChainType :: DevNet (o_0 ,) => ChainType_FFI :: DevNet (ferment_interfaces :: FFIConversion :: ffi_to (o_0) ,) , }) } unsafe fn destroy (ffi : * mut ChainType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ChainType_FFI { fn drop (& mut self) { unsafe { match self { ChainType_FFI :: MainNet => { } , ChainType_FFI :: TestNet => { } , ChainType_FFI :: DevNet (o_0 ,) => { < DevnetType_FFI as ferment_interfaces :: FFIConversion < DevnetType >> :: destroy (o_0 . to_owned ()) ; } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ChainType_FFI_destroy (ffi : * mut ChainType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [allow (non_snake_case , non_upper_case_globals)] static ChainType_IHaveChainSettings_VTable : IHaveChainSettings_VTable = { unsafe extern "C" fn ChainType_genesis_hash (obj : * const () ,) -> * mut [u8 ; 32] { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . genesis_hash () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_genesis_height (obj : * const () ,) -> u32 { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . genesis_height () ; obj } unsafe extern "C" fn ChainType_is_llmq_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . is_llmq_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_isd_llmq_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . isd_llmq_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_chain_locks_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . chain_locks_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_platform_type (obj : * const () ,) -> * mut LLMQType_FFI { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . platform_type () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } unsafe extern "C" fn ChainType_should_process_llmq_of_type (obj : * const () , llmq_type : * mut LLMQType_FFI ,) -> bool { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . should_process_llmq_of_type (ferment_interfaces :: FFIConversion :: ffi_from (llmq_type) ,) ; obj } unsafe extern "C" fn ChainType_is_evolution_enabled (obj : * const () ,) -> bool { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . is_evolution_enabled () ; obj } unsafe extern "C" fn ChainType_name (obj : * const () ,) -> * mut std :: os :: raw :: c_char { let cast_obj = & (* (obj as * const ChainType)) ; let obj = cast_obj . name () ; ferment_interfaces :: FFIConversion :: ffi_to (obj) } IHaveChainSettings_VTable { genesis_hash : ChainType_genesis_hash , genesis_height : ChainType_genesis_height , is_llmq_type : ChainType_is_llmq_type , isd_llmq_type : ChainType_isd_llmq_type , chain_locks_type : ChainType_chain_locks_type , platform_type : ChainType_platform_type , should_process_llmq_of_type : ChainType_should_process_llmq_of_type , is_evolution_enabled : ChainType_is_evolution_enabled , name : ChainType_name , } } ; # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub extern "C" fn ChainType_as_IHaveChainSettings_TraitObject (obj : * const ChainType) -> IHaveChainSettings_TraitObject { IHaveChainSettings_TraitObject { object : obj as * const () , vtable : & ChainType_IHaveChainSettings_VTable , } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ChainType_as_IHaveChainSettings_TraitObject_destroy (obj : IHaveChainSettings_TraitObject) { ferment_interfaces :: unbox_any (obj . object as * mut ChainType) ; } } } } pub mod tx { pub mod coinbase_transaction { use crate :: crypto :: UInt768 ; use crate :: crypto :: UInt256 ; use crate :: tx :: transaction :: Transaction ; use crate :: tx :: coinbase_transaction :: CoinbaseTransaction ; use crate :: fermented :: types :: tx :: transaction :: Transaction_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the CoinbaseTransaction\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct CoinbaseTransaction_FFI { pub base : * mut Transaction_FFI , pub coinbase_transaction_version : u16 , pub height : u32 , pub merkle_root_mn_list : * mut [u8 ; 32] , pub merkle_root_llmq_list : * mut [u8 ; 32] , pub best_cl_height_diff : u64 , pub best_cl_signature : * mut [u8 ; 96] , pub credit_pool_balance : i64 , } impl ferment_interfaces :: FFIConversion < CoinbaseTransaction > for CoinbaseTransaction_FFI { unsafe fn ffi_from_const (ffi : * const CoinbaseTransaction_FFI) -> CoinbaseTransaction { let ffi_ref = & * ffi ; CoinbaseTransaction { base : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . base) , coinbase_transaction_version : ffi_ref . coinbase_transaction_version , height : ffi_ref . height , merkle_root_mn_list : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . merkle_root_mn_list) , merkle_root_llmq_list : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . merkle_root_llmq_list) , best_cl_height_diff : ffi_ref . best_cl_height_diff , best_cl_signature : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . best_cl_signature) , credit_pool_balance : (ffi_ref . credit_pool_balance > 0) . then_some (ffi_ref . credit_pool_balance) , } } unsafe fn ffi_to_const (obj : CoinbaseTransaction) -> * const CoinbaseTransaction_FFI { ferment_interfaces :: boxed (CoinbaseTransaction_FFI { base : ferment_interfaces :: FFIConversion :: ffi_to (obj . base) , coinbase_transaction_version : obj . coinbase_transaction_version , height : obj . height , merkle_root_mn_list : ferment_interfaces :: FFIConversion :: ffi_to (obj . merkle_root_mn_list) , merkle_root_llmq_list : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . merkle_root_llmq_list) , best_cl_height_diff : obj . best_cl_height_diff , best_cl_signature : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . best_cl_signature) , credit_pool_balance : obj . credit_pool_balance . unwrap_or (0) , }) } unsafe fn destroy (ffi : * mut CoinbaseTransaction_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for CoinbaseTransaction_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < Transaction_FFI as ferment_interfaces :: FFIConversion < Transaction >> :: destroy (ffi_ref . base) ; { } ; { } ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . merkle_root_mn_list) ; if ! ffi_ref . merkle_root_llmq_list . is_null () { ferment_interfaces :: unbox_any (ffi_ref . merkle_root_llmq_list) ; } ; { } ; if ! ffi_ref . best_cl_signature . is_null () { ferment_interfaces :: unbox_any (ffi_ref . best_cl_signature) ; } ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn CoinbaseTransaction_FFI_destroy (ffi : * mut CoinbaseTransaction_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod transaction { use crate :: fermented :: generics :: Vec_u8_FFI ; use crate :: fermented :: generics :: Vec_crate_tx_transaction_TransactionOutput_FFI ; use crate :: fermented :: generics :: Vec_crate_tx_transaction_TransactionInput_FFI ; use crate :: tx :: transaction :: TransactionOutput ; use crate :: crypto :: UInt256 ; use crate :: tx :: transaction :: TransactionType ; use crate :: tx :: transaction :: Transaction ; use crate :: tx :: transaction :: TransactionInput ; # [doc = "FFI-representation of the TransactionType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum TransactionType_FFI { Classic = 0 , ProviderRegistration = 1 , ProviderUpdateService = 2 , ProviderUpdateRegistrar = 3 , ProviderUpdateRevocation = 4 , Coinbase = 5 , QuorumCommitment = 6 , AssetLock = 8 , AssetUnlock = 9 , TypeMax = 10 , SubscriptionCloseAccount = 11 , Transition = 12 , CreditFunding = 255 , } impl ferment_interfaces :: FFIConversion < TransactionType > for TransactionType_FFI { unsafe fn ffi_from_const (ffi : * const TransactionType_FFI) -> TransactionType { let ffi_ref = & * ffi ; match ffi_ref { TransactionType_FFI :: Classic => TransactionType :: Classic , TransactionType_FFI :: ProviderRegistration => TransactionType :: ProviderRegistration , TransactionType_FFI :: ProviderUpdateService => TransactionType :: ProviderUpdateService , TransactionType_FFI :: ProviderUpdateRegistrar => TransactionType :: ProviderUpdateRegistrar , TransactionType_FFI :: ProviderUpdateRevocation => TransactionType :: ProviderUpdateRevocation , TransactionType_FFI :: Coinbase => TransactionType :: Coinbase , TransactionType_FFI :: QuorumCommitment => TransactionType :: QuorumCommitment , TransactionType_FFI :: AssetLock => TransactionType :: AssetLock , TransactionType_FFI :: AssetUnlock => TransactionType :: AssetUnlock , TransactionType_FFI :: TypeMax => TransactionType :: TypeMax , TransactionType_FFI :: SubscriptionCloseAccount => TransactionType :: SubscriptionCloseAccount , TransactionType_FFI :: Transition => TransactionType :: Transition , TransactionType_FFI :: CreditFunding => TransactionType :: CreditFunding , } } unsafe fn ffi_to_const (obj : TransactionType) -> * const TransactionType_FFI { ferment_interfaces :: boxed (match obj { TransactionType :: Classic => TransactionType_FFI :: Classic , TransactionType :: ProviderRegistration => TransactionType_FFI :: ProviderRegistration , TransactionType :: ProviderUpdateService => TransactionType_FFI :: ProviderUpdateService , TransactionType :: ProviderUpdateRegistrar => TransactionType_FFI :: ProviderUpdateRegistrar , TransactionType :: ProviderUpdateRevocation => TransactionType_FFI :: ProviderUpdateRevocation , TransactionType :: Coinbase => TransactionType_FFI :: Coinbase , TransactionType :: QuorumCommitment => TransactionType_FFI :: QuorumCommitment , TransactionType :: AssetLock => TransactionType_FFI :: AssetLock , TransactionType :: AssetUnlock => TransactionType_FFI :: AssetUnlock , TransactionType :: TypeMax => TransactionType_FFI :: TypeMax , TransactionType :: SubscriptionCloseAccount => TransactionType_FFI :: SubscriptionCloseAccount , TransactionType :: Transition => TransactionType_FFI :: Transition , TransactionType :: CreditFunding => TransactionType_FFI :: CreditFunding , }) } unsafe fn destroy (ffi : * mut TransactionType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TransactionType_FFI { fn drop (& mut self) { unsafe { match self { TransactionType_FFI :: Classic => { } , TransactionType_FFI :: ProviderRegistration => { } , TransactionType_FFI :: ProviderUpdateService => { } , TransactionType_FFI :: ProviderUpdateRegistrar => { } , TransactionType_FFI :: ProviderUpdateRevocation => { } , TransactionType_FFI :: Coinbase => { } , TransactionType_FFI :: QuorumCommitment => { } , TransactionType_FFI :: AssetLock => { } , TransactionType_FFI :: AssetUnlock => { } , TransactionType_FFI :: TypeMax => { } , TransactionType_FFI :: SubscriptionCloseAccount => { } , TransactionType_FFI :: Transition => { } , TransactionType_FFI :: CreditFunding => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TransactionType_FFI_destroy (ffi : * mut TransactionType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the TransactionInput\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct TransactionInput_FFI { pub input_hash : * mut [u8 ; 32] , pub index : u32 , pub script : * mut Vec_u8_FFI , pub signature : * mut Vec_u8_FFI , pub sequence : u32 , } impl ferment_interfaces :: FFIConversion < TransactionInput > for TransactionInput_FFI { unsafe fn ffi_from_const (ffi : * const TransactionInput_FFI) -> TransactionInput { let ffi_ref = & * ffi ; TransactionInput { input_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . input_hash) , index : ffi_ref . index , script : (! ffi_ref . script . is_null ()) . then_some ({ let vec = & * ffi_ref . script ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) }) , signature : (! ffi_ref . signature . is_null ()) . then_some ({ let vec = & * ffi_ref . signature ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) }) , sequence : ffi_ref . sequence , } } unsafe fn ffi_to_const (obj : TransactionInput) -> * const TransactionInput_FFI { ferment_interfaces :: boxed (TransactionInput_FFI { input_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . input_hash) , index : obj . index , script : match obj . script { Some (vec) => ferment_interfaces :: FFIConversion :: ffi_to (vec) , None => std :: ptr :: null_mut () , } , signature : match obj . signature { Some (vec) => ferment_interfaces :: FFIConversion :: ffi_to (vec) , None => std :: ptr :: null_mut () , } , sequence : obj . sequence , }) } unsafe fn destroy (ffi : * mut TransactionInput_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TransactionInput_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . input_hash) ; { } ; if ! ffi_ref . script . is_null () { ferment_interfaces :: unbox_any (ffi_ref . script) ; ; } ; if ! ffi_ref . signature . is_null () { ferment_interfaces :: unbox_any (ffi_ref . signature) ; ; } ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TransactionInput_FFI_destroy (ffi : * mut TransactionInput_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the Transaction\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Transaction_FFI { pub inputs : * mut Vec_crate_tx_transaction_TransactionInput_FFI , pub outputs : * mut Vec_crate_tx_transaction_TransactionOutput_FFI , pub lock_time : u32 , pub version : u16 , pub tx_hash : * mut [u8 ; 32] , pub tx_type : * mut TransactionType_FFI , pub payload_offset : usize , pub block_height : u32 , } impl ferment_interfaces :: FFIConversion < Transaction > for Transaction_FFI { unsafe fn ffi_from_const (ffi : * const Transaction_FFI) -> Transaction { let ffi_ref = & * ffi ; Transaction { inputs : { let vec = & * ffi_ref . inputs ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , outputs : { let vec = & * ffi_ref . outputs ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , lock_time : ffi_ref . lock_time , version : ffi_ref . version , tx_hash : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . tx_hash) , tx_type : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . tx_type) , payload_offset : ffi_ref . payload_offset , block_height : ffi_ref . block_height , } } unsafe fn ffi_to_const (obj : Transaction) -> * const Transaction_FFI { ferment_interfaces :: boxed (Transaction_FFI { inputs : ferment_interfaces :: FFIConversion :: ffi_to (obj . inputs) , outputs : ferment_interfaces :: FFIConversion :: ffi_to (obj . outputs) , lock_time : obj . lock_time , version : obj . version , tx_hash : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . tx_hash) , tx_type : ferment_interfaces :: FFIConversion :: ffi_to (obj . tx_type) , payload_offset : obj . payload_offset , block_height : obj . block_height , }) } unsafe fn destroy (ffi : * mut Transaction_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Transaction_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . inputs) ; ; ferment_interfaces :: unbox_any (ffi_ref . outputs) ; ; { } ; { } ; if ! ffi_ref . tx_hash . is_null () { ferment_interfaces :: unbox_any (ffi_ref . tx_hash) ; } ; < TransactionType_FFI as ferment_interfaces :: FFIConversion < TransactionType >> :: destroy (ffi_ref . tx_type) ; { } ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Transaction_FFI_destroy (ffi : * mut Transaction_FFI) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the TransactionOutput\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct TransactionOutput_FFI { pub amount : u64 , pub script : * mut Vec_u8_FFI , pub address : * mut Vec_u8_FFI , } impl ferment_interfaces :: FFIConversion < TransactionOutput > for TransactionOutput_FFI { unsafe fn ffi_from_const (ffi : * const TransactionOutput_FFI) -> TransactionOutput { let ffi_ref = & * ffi ; TransactionOutput { amount : ffi_ref . amount , script : (! ffi_ref . script . is_null ()) . then_some ({ let vec = & * ffi_ref . script ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) }) , address : (! ffi_ref . address . is_null ()) . then_some ({ let vec = & * ffi_ref . address ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) }) , } } unsafe fn ffi_to_const (obj : TransactionOutput) -> * const TransactionOutput_FFI { ferment_interfaces :: boxed (TransactionOutput_FFI { amount : obj . amount , script : match obj . script { Some (vec) => ferment_interfaces :: FFIConversion :: ffi_to (vec) , None => std :: ptr :: null_mut () , } , address : match obj . address { Some (vec) => ferment_interfaces :: FFIConversion :: ffi_to (vec) , None => std :: ptr :: null_mut () , } , }) } unsafe fn destroy (ffi : * mut TransactionOutput_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for TransactionOutput_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; if ! ffi_ref . script . is_null () { ferment_interfaces :: unbox_any (ffi_ref . script) ; ; } ; if ! ffi_ref . address . is_null () { ferment_interfaces :: unbox_any (ffi_ref . address) ; ; } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn TransactionOutput_FFI_destroy (ffi : * mut TransactionOutput_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } pub mod common { pub mod socket_address { use crate :: crypto :: UInt128 ; use crate :: common :: socket_address :: SocketAddress ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the SocketAddress\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct SocketAddress_FFI { pub ip_address : * mut [u8 ; 16] , pub port : u16 , } impl ferment_interfaces :: FFIConversion < SocketAddress > for SocketAddress_FFI { unsafe fn ffi_from_const (ffi : * const SocketAddress_FFI) -> SocketAddress { let ffi_ref = & * ffi ; SocketAddress { ip_address : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . ip_address) , port : ffi_ref . port , } } unsafe fn ffi_to_const (obj : SocketAddress) -> * const SocketAddress_FFI { ferment_interfaces :: boxed (SocketAddress_FFI { ip_address : ferment_interfaces :: FFIConversion :: ffi_to (obj . ip_address) , port : obj . port , }) } unsafe fn destroy (ffi : * mut SocketAddress_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for SocketAddress_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < [u8 ; 16] as ferment_interfaces :: FFIConversion < UInt128 >> :: destroy (ffi_ref . ip_address) ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn SocketAddress_FFI_destroy (ffi : * mut SocketAddress_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod masternode_type { use crate :: common :: masternode_type :: MasternodeType ; # [doc = "FFI-representation of the MasternodeType"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum MasternodeType_FFI { Regular = 0 , HighPerformance = 1 , } impl ferment_interfaces :: FFIConversion < MasternodeType > for MasternodeType_FFI { unsafe fn ffi_from_const (ffi : * const MasternodeType_FFI) -> MasternodeType { let ffi_ref = & * ffi ; match ffi_ref { MasternodeType_FFI :: Regular => MasternodeType :: Regular , MasternodeType_FFI :: HighPerformance => MasternodeType :: HighPerformance , } } unsafe fn ffi_to_const (obj : MasternodeType) -> * const MasternodeType_FFI { ferment_interfaces :: boxed (match obj { MasternodeType :: Regular => MasternodeType_FFI :: Regular , MasternodeType :: HighPerformance => MasternodeType_FFI :: HighPerformance , }) } unsafe fn destroy (ffi : * mut MasternodeType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MasternodeType_FFI { fn drop (& mut self) { unsafe { match self { MasternodeType_FFI :: Regular => { } , MasternodeType_FFI :: HighPerformance => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MasternodeType_FFI_destroy (ffi : * mut MasternodeType_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod llmq_snapshot_skip_mode { use crate :: common :: llmq_snapshot_skip_mode :: LLMQSnapshotSkipMode ; # [doc = "FFI-representation of the LLMQSnapshotSkipMode"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum LLMQSnapshotSkipMode_FFI { NoSkipping = 0 , SkipFirst = 1 , SkipExcept = 2 , SkipAll = 3 , } impl ferment_interfaces :: FFIConversion < LLMQSnapshotSkipMode > for LLMQSnapshotSkipMode_FFI { unsafe fn ffi_from_const (ffi : * const LLMQSnapshotSkipMode_FFI) -> LLMQSnapshotSkipMode { let ffi_ref = & * ffi ; match ffi_ref { LLMQSnapshotSkipMode_FFI :: NoSkipping => LLMQSnapshotSkipMode :: NoSkipping , LLMQSnapshotSkipMode_FFI :: SkipFirst => LLMQSnapshotSkipMode :: SkipFirst , LLMQSnapshotSkipMode_FFI :: SkipExcept => LLMQSnapshotSkipMode :: SkipExcept , LLMQSnapshotSkipMode_FFI :: SkipAll => LLMQSnapshotSkipMode :: SkipAll , } } unsafe fn ffi_to_const (obj : LLMQSnapshotSkipMode) -> * const LLMQSnapshotSkipMode_FFI { ferment_interfaces :: boxed (match obj { LLMQSnapshotSkipMode :: NoSkipping => LLMQSnapshotSkipMode_FFI :: NoSkipping , LLMQSnapshotSkipMode :: SkipFirst => LLMQSnapshotSkipMode_FFI :: SkipFirst , LLMQSnapshotSkipMode :: SkipExcept => LLMQSnapshotSkipMode_FFI :: SkipExcept , LLMQSnapshotSkipMode :: SkipAll => LLMQSnapshotSkipMode_FFI :: SkipAll , }) } unsafe fn destroy (ffi : * mut LLMQSnapshotSkipMode_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQSnapshotSkipMode_FFI { fn drop (& mut self) { unsafe { match self { LLMQSnapshotSkipMode_FFI :: NoSkipping => { } , LLMQSnapshotSkipMode_FFI :: SkipFirst => { } , LLMQSnapshotSkipMode_FFI :: SkipExcept => { } , LLMQSnapshotSkipMode_FFI :: SkipAll => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQSnapshotSkipMode_FFI_destroy (ffi : * mut LLMQSnapshotSkipMode_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod bitset { use crate :: common :: bitset :: Bitset ; use crate :: fermented :: generics :: Vec_u8_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the Bitset\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Bitset_FFI { pub count : usize , pub bitset : * mut Vec_u8_FFI , } impl ferment_interfaces :: FFIConversion < Bitset > for Bitset_FFI { unsafe fn ffi_from_const (ffi : * const Bitset_FFI) -> Bitset { let ffi_ref = & * ffi ; Bitset { count : ffi_ref . count , bitset : { let vec = & * ffi_ref . bitset ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) } , } } unsafe fn ffi_to_const (obj : Bitset) -> * const Bitset_FFI { ferment_interfaces :: boxed (Bitset_FFI { count : obj . count , bitset : ferment_interfaces :: FFIConversion :: ffi_to (obj . bitset) , }) } unsafe fn destroy (ffi : * mut Bitset_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Bitset_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; ferment_interfaces :: unbox_any (ffi_ref . bitset) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Bitset_FFI_destroy (ffi : * mut Bitset_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod llmq_version { use crate :: common :: llmq_version :: LLMQVersion ; # [doc = "FFI-representation of the LLMQVersion"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum LLMQVersion_FFI { Default = 1 , Indexed = 2 , BLSBasicDefault = 3 , BLSBasicIndexed = 4 , } impl ferment_interfaces :: FFIConversion < LLMQVersion > for LLMQVersion_FFI { unsafe fn ffi_from_const (ffi : * const LLMQVersion_FFI) -> LLMQVersion { let ffi_ref = & * ffi ; match ffi_ref { LLMQVersion_FFI :: Default => LLMQVersion :: Default , LLMQVersion_FFI :: Indexed => LLMQVersion :: Indexed , LLMQVersion_FFI :: BLSBasicDefault => LLMQVersion :: BLSBasicDefault , LLMQVersion_FFI :: BLSBasicIndexed => LLMQVersion :: BLSBasicIndexed , } } unsafe fn ffi_to_const (obj : LLMQVersion) -> * const LLMQVersion_FFI { ferment_interfaces :: boxed (match obj { LLMQVersion :: Default => LLMQVersion_FFI :: Default , LLMQVersion :: Indexed => LLMQVersion_FFI :: Indexed , LLMQVersion :: BLSBasicDefault => LLMQVersion_FFI :: BLSBasicDefault , LLMQVersion :: BLSBasicIndexed => LLMQVersion_FFI :: BLSBasicIndexed , }) } unsafe fn destroy (ffi : * mut LLMQVersion_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQVersion_FFI { fn drop (& mut self) { unsafe { match self { LLMQVersion_FFI :: Default => { } , LLMQVersion_FFI :: Indexed => { } , LLMQVersion_FFI :: BLSBasicDefault => { } , LLMQVersion_FFI :: BLSBasicIndexed => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQVersion_FFI_destroy (ffi : * mut LLMQVersion_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod block { use crate :: common :: block :: Block ; use crate :: crypto :: UInt256 ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the Block\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Block_FFI { pub height : u32 , pub hash : * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < Block > for Block_FFI { unsafe fn ffi_from_const (ffi : * const Block_FFI) -> Block { let ffi_ref = & * ffi ; Block { height : ffi_ref . height , hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . hash) , } } unsafe fn ffi_to_const (obj : Block) -> * const Block_FFI { ferment_interfaces :: boxed (Block_FFI { height : obj . height , hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . hash) , }) } unsafe fn destroy (ffi : * mut Block_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for Block_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . hash) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn Block_FFI_destroy (ffi : * mut Block_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } pub mod models { pub mod masternode_entry { use crate :: common :: block :: Block ; use crate :: common :: socket_address :: SocketAddress ; use crate :: models :: masternode_entry :: MasternodeEntry ; use crate :: crypto :: UInt256 ; use crate :: common :: masternode_type :: MasternodeType ; use crate :: models :: operator_public_key :: OperatorPublicKey ; use crate :: crypto :: UInt160 ; use std :: collections :: BTreeMap ; use crate :: fermented :: types :: common :: socket_address :: SocketAddress_FFI ; use crate :: fermented :: types :: common :: block :: Block_FFI ; use crate :: fermented :: types :: common :: masternode_type :: MasternodeType_FFI ; use crate :: fermented :: types :: models :: operator_public_key :: OperatorPublicKey_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_common_block_Block_values_bool_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the MasternodeEntry\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct MasternodeEntry_FFI { pub provider_registration_transaction_hash : * mut [u8 ; 32] , pub confirmed_hash : * mut [u8 ; 32] , pub confirmed_hash_hashed_with_provider_registration_transaction_hash : * mut [u8 ; 32] , pub socket_address : * mut SocketAddress_FFI , pub operator_public_key : * mut OperatorPublicKey_FFI , pub previous_operator_public_keys : * mut std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI , pub previous_entry_hashes : * mut std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI , pub previous_validity : * mut std_collections_Map_keys_crate_common_block_Block_values_bool_FFI , pub known_confirmed_at_height : u32 , pub update_height : u32 , pub key_id_voting : * mut [u8 ; 20] , pub is_valid : bool , pub mn_type : * mut MasternodeType_FFI , pub platform_http_port : u16 , pub platform_node_id : * mut [u8 ; 20] , pub entry_hash : * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < MasternodeEntry > for MasternodeEntry_FFI { unsafe fn ffi_from_const (ffi : * const MasternodeEntry_FFI) -> MasternodeEntry { let ffi_ref = & * ffi ; MasternodeEntry { provider_registration_transaction_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . provider_registration_transaction_hash) , confirmed_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . confirmed_hash) , confirmed_hash_hashed_with_provider_registration_transaction_hash : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . confirmed_hash_hashed_with_provider_registration_transaction_hash) , socket_address : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . socket_address) , operator_public_key : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . operator_public_key) , previous_operator_public_keys : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . previous_operator_public_keys) , previous_entry_hashes : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . previous_entry_hashes) , previous_validity : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . previous_validity) , known_confirmed_at_height : (ffi_ref . known_confirmed_at_height > 0) . then_some (ffi_ref . known_confirmed_at_height) , update_height : ffi_ref . update_height , key_id_voting : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . key_id_voting) , is_valid : ffi_ref . is_valid , mn_type : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . mn_type) , platform_http_port : ffi_ref . platform_http_port , platform_node_id : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . platform_node_id) , entry_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . entry_hash) , } } unsafe fn ffi_to_const (obj : MasternodeEntry) -> * const MasternodeEntry_FFI { ferment_interfaces :: boxed (MasternodeEntry_FFI { provider_registration_transaction_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . provider_registration_transaction_hash) , confirmed_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . confirmed_hash) , confirmed_hash_hashed_with_provider_registration_transaction_hash : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . confirmed_hash_hashed_with_provider_registration_transaction_hash) , socket_address : ferment_interfaces :: FFIConversion :: ffi_to (obj . socket_address) , operator_public_key : ferment_interfaces :: FFIConversion :: ffi_to (obj . operator_public_key) , previous_operator_public_keys : ferment_interfaces :: FFIConversion :: ffi_to (obj . previous_operator_public_keys) , previous_entry_hashes : ferment_interfaces :: FFIConversion :: ffi_to (obj . previous_entry_hashes) , previous_validity : ferment_interfaces :: FFIConversion :: ffi_to (obj . previous_validity) , known_confirmed_at_height : obj . known_confirmed_at_height . unwrap_or (0) , update_height : obj . update_height , key_id_voting : ferment_interfaces :: FFIConversion :: ffi_to (obj . key_id_voting) , is_valid : obj . is_valid , mn_type : ferment_interfaces :: FFIConversion :: ffi_to (obj . mn_type) , platform_http_port : obj . platform_http_port , platform_node_id : ferment_interfaces :: FFIConversion :: ffi_to (obj . platform_node_id) , entry_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . entry_hash) , }) } unsafe fn destroy (ffi : * mut MasternodeEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MasternodeEntry_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . provider_registration_transaction_hash) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . confirmed_hash) ; if ! ffi_ref . confirmed_hash_hashed_with_provider_registration_transaction_hash . is_null () { ferment_interfaces :: unbox_any (ffi_ref . confirmed_hash_hashed_with_provider_registration_transaction_hash) ; } ; < SocketAddress_FFI as ferment_interfaces :: FFIConversion < SocketAddress >> :: destroy (ffi_ref . socket_address) ; < OperatorPublicKey_FFI as ferment_interfaces :: FFIConversion < OperatorPublicKey >> :: destroy (ffi_ref . operator_public_key) ; ferment_interfaces :: unbox_any (ffi_ref . previous_operator_public_keys) ; ; ferment_interfaces :: unbox_any (ffi_ref . previous_entry_hashes) ; ; ferment_interfaces :: unbox_any (ffi_ref . previous_validity) ; ; { } ; { } ; < [u8 ; 20] as ferment_interfaces :: FFIConversion < UInt160 >> :: destroy (ffi_ref . key_id_voting) ; { } ; < MasternodeType_FFI as ferment_interfaces :: FFIConversion < MasternodeType >> :: destroy (ffi_ref . mn_type) ; { } ; < [u8 ; 20] as ferment_interfaces :: FFIConversion < UInt160 >> :: destroy (ffi_ref . platform_node_id) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . entry_hash) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MasternodeEntry_FFI_destroy (ffi : * mut MasternodeEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod llmq_entry { use crate :: crypto :: UInt256 ; use crate :: common :: bitset :: Bitset ; use crate :: crypto :: UInt384 ; use crate :: crypto :: UInt768 ; use crate :: models :: llmq_entry :: LLMQEntry ; use crate :: chain :: common :: llmq_type :: LLMQType ; use crate :: common :: llmq_version :: LLMQVersion ; use crate :: fermented :: types :: common :: bitset :: Bitset_FFI ; use crate :: fermented :: types :: chain :: common :: llmq_type :: LLMQType_FFI ; use crate :: fermented :: types :: common :: llmq_version :: LLMQVersion_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the LLMQEntry\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct LLMQEntry_FFI { pub version : * mut LLMQVersion_FFI , pub llmq_hash : * mut [u8 ; 32] , pub index : u16 , pub public_key : * mut [u8 ; 48] , pub threshold_signature : * mut [u8 ; 96] , pub verification_vector_hash : * mut [u8 ; 32] , pub all_commitment_aggregated_signature : * mut [u8 ; 96] , pub llmq_type : * mut LLMQType_FFI , pub signers : * mut Bitset_FFI , pub valid_members : * mut Bitset_FFI , pub entry_hash : * mut [u8 ; 32] , pub verified : bool , pub saved : bool , pub commitment_hash : * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < LLMQEntry > for LLMQEntry_FFI { unsafe fn ffi_from_const (ffi : * const LLMQEntry_FFI) -> LLMQEntry { let ffi_ref = & * ffi ; LLMQEntry { version : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . version) , llmq_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . llmq_hash) , index : (ffi_ref . index > 0) . then_some (ffi_ref . index) , public_key : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . public_key) , threshold_signature : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . threshold_signature) , verification_vector_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . verification_vector_hash) , all_commitment_aggregated_signature : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . all_commitment_aggregated_signature) , llmq_type : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . llmq_type) , signers : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . signers) , valid_members : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . valid_members) , entry_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . entry_hash) , verified : ffi_ref . verified , saved : ffi_ref . saved , commitment_hash : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . commitment_hash) , } } unsafe fn ffi_to_const (obj : LLMQEntry) -> * const LLMQEntry_FFI { ferment_interfaces :: boxed (LLMQEntry_FFI { version : ferment_interfaces :: FFIConversion :: ffi_to (obj . version) , llmq_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . llmq_hash) , index : obj . index . unwrap_or (0) , public_key : ferment_interfaces :: FFIConversion :: ffi_to (obj . public_key) , threshold_signature : ferment_interfaces :: FFIConversion :: ffi_to (obj . threshold_signature) , verification_vector_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . verification_vector_hash) , all_commitment_aggregated_signature : ferment_interfaces :: FFIConversion :: ffi_to (obj . all_commitment_aggregated_signature) , llmq_type : ferment_interfaces :: FFIConversion :: ffi_to (obj . llmq_type) , signers : ferment_interfaces :: FFIConversion :: ffi_to (obj . signers) , valid_members : ferment_interfaces :: FFIConversion :: ffi_to (obj . valid_members) , entry_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . entry_hash) , verified : obj . verified , saved : obj . saved , commitment_hash : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . commitment_hash) , }) } unsafe fn destroy (ffi : * mut LLMQEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQEntry_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < LLMQVersion_FFI as ferment_interfaces :: FFIConversion < LLMQVersion >> :: destroy (ffi_ref . version) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . llmq_hash) ; { } ; < [u8 ; 48] as ferment_interfaces :: FFIConversion < UInt384 >> :: destroy (ffi_ref . public_key) ; < [u8 ; 96] as ferment_interfaces :: FFIConversion < UInt768 >> :: destroy (ffi_ref . threshold_signature) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . verification_vector_hash) ; < [u8 ; 96] as ferment_interfaces :: FFIConversion < UInt768 >> :: destroy (ffi_ref . all_commitment_aggregated_signature) ; < LLMQType_FFI as ferment_interfaces :: FFIConversion < LLMQType >> :: destroy (ffi_ref . llmq_type) ; < Bitset_FFI as ferment_interfaces :: FFIConversion < Bitset >> :: destroy (ffi_ref . signers) ; < Bitset_FFI as ferment_interfaces :: FFIConversion < Bitset >> :: destroy (ffi_ref . valid_members) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . entry_hash) ; { } ; { } ; if ! ffi_ref . commitment_hash . is_null () { ferment_interfaces :: unbox_any (ffi_ref . commitment_hash) ; } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQEntry_FFI_destroy (ffi : * mut LLMQEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod operator_public_key { use crate :: crypto :: UInt384 ; use crate :: models :: operator_public_key :: OperatorPublicKey ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the OperatorPublicKey\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct OperatorPublicKey_FFI { pub data : * mut [u8 ; 48] , pub version : u16 , } impl ferment_interfaces :: FFIConversion < OperatorPublicKey > for OperatorPublicKey_FFI { unsafe fn ffi_from_const (ffi : * const OperatorPublicKey_FFI) -> OperatorPublicKey { let ffi_ref = & * ffi ; OperatorPublicKey { data : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . data) , version : ffi_ref . version , } } unsafe fn ffi_to_const (obj : OperatorPublicKey) -> * const OperatorPublicKey_FFI { ferment_interfaces :: boxed (OperatorPublicKey_FFI { data : ferment_interfaces :: FFIConversion :: ffi_to (obj . data) , version : obj . version , }) } unsafe fn destroy (ffi : * mut OperatorPublicKey_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for OperatorPublicKey_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < [u8 ; 48] as ferment_interfaces :: FFIConversion < UInt384 >> :: destroy (ffi_ref . data) ; { } ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn OperatorPublicKey_FFI_destroy (ffi : * mut OperatorPublicKey_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod masternode_list { use crate :: fermented :: types :: chain :: common :: llmq_type :: LLMQType_FFI ; use crate :: fermented :: types :: models :: masternode_entry :: MasternodeEntry_FFI ; use crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI ; use std :: collections :: BTreeMap ; use crate :: chain :: common :: llmq_type :: LLMQType ; use crate :: models :: masternode_entry :: MasternodeEntry ; use crate :: crypto :: UInt256 ; use crate :: models :: llmq_entry :: LLMQEntry ; use crate :: models :: masternode_list :: MasternodeList ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the MasternodeList\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct MasternodeList_FFI { pub block_hash : * mut [u8 ; 32] , pub known_height : u32 , pub masternode_merkle_root : * mut [u8 ; 32] , pub llmq_merkle_root : * mut [u8 ; 32] , pub masternodes : * mut std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI , pub quorums : * mut std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI , } impl ferment_interfaces :: FFIConversion < MasternodeList > for MasternodeList_FFI { unsafe fn ffi_from_const (ffi : * const MasternodeList_FFI) -> MasternodeList { let ffi_ref = & * ffi ; MasternodeList { block_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . block_hash) , known_height : ffi_ref . known_height , masternode_merkle_root : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . masternode_merkle_root) , llmq_merkle_root : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . llmq_merkle_root) , masternodes : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . masternodes) , quorums : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . quorums) , } } unsafe fn ffi_to_const (obj : MasternodeList) -> * const MasternodeList_FFI { ferment_interfaces :: boxed (MasternodeList_FFI { block_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . block_hash) , known_height : obj . known_height , masternode_merkle_root : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . masternode_merkle_root) , llmq_merkle_root : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . llmq_merkle_root) , masternodes : ferment_interfaces :: FFIConversion :: ffi_to (obj . masternodes) , quorums : ferment_interfaces :: FFIConversion :: ffi_to (obj . quorums) , }) } unsafe fn destroy (ffi : * mut MasternodeList_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MasternodeList_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . block_hash) ; { } ; if ! ffi_ref . masternode_merkle_root . is_null () { ferment_interfaces :: unbox_any (ffi_ref . masternode_merkle_root) ; } ; if ! ffi_ref . llmq_merkle_root . is_null () { ferment_interfaces :: unbox_any (ffi_ref . llmq_merkle_root) ; } ; ferment_interfaces :: unbox_any (ffi_ref . masternodes) ; ; ferment_interfaces :: unbox_any (ffi_ref . quorums) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MasternodeList_FFI_destroy (ffi : * mut MasternodeList_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod llmq_indexed_hash { use crate :: crypto :: UInt256 ; use crate :: models :: llmq_indexed_hash :: LLMQIndexedHash ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the LLMQIndexedHash\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct LLMQIndexedHash_FFI { pub index : u32 , pub hash : * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < LLMQIndexedHash > for LLMQIndexedHash_FFI { unsafe fn ffi_from_const (ffi : * const LLMQIndexedHash_FFI) -> LLMQIndexedHash { let ffi_ref = & * ffi ; LLMQIndexedHash { index : ffi_ref . index , hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . hash) , } } unsafe fn ffi_to_const (obj : LLMQIndexedHash) -> * const LLMQIndexedHash_FFI { ferment_interfaces :: boxed (LLMQIndexedHash_FFI { index : obj . index , hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . hash) , }) } unsafe fn destroy (ffi : * mut LLMQIndexedHash_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQIndexedHash_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; { } ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . hash) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQIndexedHash_FFI_destroy (ffi : * mut LLMQIndexedHash_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod llmq_typed_hash { use crate :: fermented :: types :: chain :: common :: llmq_type :: LLMQType_FFI ; use crate :: chain :: common :: llmq_type :: LLMQType ; use crate :: crypto :: UInt256 ; use crate :: models :: llmq_typed_hash :: LLMQTypedHash ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the LLMQTypedHash\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct LLMQTypedHash_FFI { pub llmq_type : * mut LLMQType_FFI , pub hash : * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < LLMQTypedHash > for LLMQTypedHash_FFI { unsafe fn ffi_from_const (ffi : * const LLMQTypedHash_FFI) -> LLMQTypedHash { let ffi_ref = & * ffi ; LLMQTypedHash { llmq_type : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . llmq_type) , hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . hash) , } } unsafe fn ffi_to_const (obj : LLMQTypedHash) -> * const LLMQTypedHash_FFI { ferment_interfaces :: boxed (LLMQTypedHash_FFI { llmq_type : ferment_interfaces :: FFIConversion :: ffi_to (obj . llmq_type) , hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . hash) , }) } unsafe fn destroy (ffi : * mut LLMQTypedHash_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQTypedHash_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < LLMQType_FFI as ferment_interfaces :: FFIConversion < LLMQType >> :: destroy (ffi_ref . llmq_type) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . hash) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQTypedHash_FFI_destroy (ffi : * mut LLMQTypedHash_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod snapshot { use crate :: fermented :: types :: common :: llmq_snapshot_skip_mode :: LLMQSnapshotSkipMode_FFI ; use crate :: common :: llmq_snapshot_skip_mode :: LLMQSnapshotSkipMode ; use crate :: models :: snapshot :: LLMQSnapshot ; use crate :: fermented :: generics :: Vec_u8_FFI ; use crate :: fermented :: generics :: Vec_i32_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the LLMQSnapshot\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct LLMQSnapshot_FFI { pub member_list : * mut Vec_u8_FFI , pub skip_list : * mut Vec_i32_FFI , pub skip_list_mode : * mut LLMQSnapshotSkipMode_FFI , } impl ferment_interfaces :: FFIConversion < LLMQSnapshot > for LLMQSnapshot_FFI { unsafe fn ffi_from_const (ffi : * const LLMQSnapshot_FFI) -> LLMQSnapshot { let ffi_ref = & * ffi ; LLMQSnapshot { member_list : { let vec = & * ffi_ref . member_list ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) } , skip_list : { let vec = & * ffi_ref . skip_list ; ferment_interfaces :: from_simple_vec (vec . values , vec . count) } , skip_list_mode : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . skip_list_mode) , } } unsafe fn ffi_to_const (obj : LLMQSnapshot) -> * const LLMQSnapshot_FFI { ferment_interfaces :: boxed (LLMQSnapshot_FFI { member_list : ferment_interfaces :: FFIConversion :: ffi_to (obj . member_list) , skip_list : ferment_interfaces :: FFIConversion :: ffi_to (obj . skip_list) , skip_list_mode : ferment_interfaces :: FFIConversion :: ffi_to (obj . skip_list_mode) , }) } unsafe fn destroy (ffi : * mut LLMQSnapshot_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for LLMQSnapshot_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; ferment_interfaces :: unbox_any (ffi_ref . member_list) ; ; ferment_interfaces :: unbox_any (ffi_ref . skip_list) ; ; < LLMQSnapshotSkipMode_FFI as ferment_interfaces :: FFIConversion < LLMQSnapshotSkipMode >> :: destroy (ffi_ref . skip_list_mode) ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn LLMQSnapshot_FFI_destroy (ffi : * mut LLMQSnapshot_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } pub mod processing { pub mod processing_error { use crate :: processing :: processing_error :: ProcessingError ; # [doc = "FFI-representation of the ProcessingError"] # [repr (C)] # [allow (non_camel_case_types)] # [derive (Clone)] pub enum ProcessingError_FFI { None = 0 , PersistInRetrieval = 1 , LocallyStored = 2 , ParseError = 3 , HasNoBaseBlockHash = 4 , UnknownBlockHash = 5 , } impl ferment_interfaces :: FFIConversion < ProcessingError > for ProcessingError_FFI { unsafe fn ffi_from_const (ffi : * const ProcessingError_FFI) -> ProcessingError { let ffi_ref = & * ffi ; match ffi_ref { ProcessingError_FFI :: None => ProcessingError :: None , ProcessingError_FFI :: PersistInRetrieval => ProcessingError :: PersistInRetrieval , ProcessingError_FFI :: LocallyStored => ProcessingError :: LocallyStored , ProcessingError_FFI :: ParseError => ProcessingError :: ParseError , ProcessingError_FFI :: HasNoBaseBlockHash => ProcessingError :: HasNoBaseBlockHash , ProcessingError_FFI :: UnknownBlockHash => ProcessingError :: UnknownBlockHash , } } unsafe fn ffi_to_const (obj : ProcessingError) -> * const ProcessingError_FFI { ferment_interfaces :: boxed (match obj { ProcessingError :: None => ProcessingError_FFI :: None , ProcessingError :: PersistInRetrieval => ProcessingError_FFI :: PersistInRetrieval , ProcessingError :: LocallyStored => ProcessingError_FFI :: LocallyStored , ProcessingError :: ParseError => ProcessingError_FFI :: ParseError , ProcessingError :: HasNoBaseBlockHash => ProcessingError_FFI :: HasNoBaseBlockHash , ProcessingError :: UnknownBlockHash => ProcessingError_FFI :: UnknownBlockHash , }) } unsafe fn destroy (ffi : * mut ProcessingError_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for ProcessingError_FFI { fn drop (& mut self) { unsafe { match self { ProcessingError_FFI :: None => { } , ProcessingError_FFI :: PersistInRetrieval => { } , ProcessingError_FFI :: LocallyStored => { } , ProcessingError_FFI :: ParseError => { } , ProcessingError_FFI :: HasNoBaseBlockHash => { } , ProcessingError_FFI :: UnknownBlockHash => { } , } } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn ProcessingError_FFI_destroy (ffi : * mut ProcessingError_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod qr_info_result { use crate :: models :: snapshot :: LLMQSnapshot ; use crate :: processing :: mn_listdiff_result :: MNListDiffResult ; use crate :: models :: llmq_entry :: LLMQEntry ; use crate :: processing :: qr_info_result :: QRInfoResult ; use crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI ; use crate :: fermented :: types :: processing :: mn_listdiff_result :: MNListDiffResult_FFI ; use crate :: fermented :: types :: models :: snapshot :: LLMQSnapshot_FFI ; use crate :: fermented :: generics :: Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI ; use crate :: fermented :: generics :: Vec_crate_models_llmq_entry_LLMQEntry_FFI ; use crate :: fermented :: generics :: Vec_crate_models_snapshot_LLMQSnapshot_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the QRInfoResult\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct QRInfoResult_FFI { pub result_at_tip : * mut MNListDiffResult_FFI , pub result_at_h : * mut MNListDiffResult_FFI , pub result_at_h_c : * mut MNListDiffResult_FFI , pub result_at_h_2c : * mut MNListDiffResult_FFI , pub result_at_h_3c : * mut MNListDiffResult_FFI , pub result_at_h_4c : * mut MNListDiffResult_FFI , pub snapshot_at_h_c : * mut LLMQSnapshot_FFI , pub snapshot_at_h_2c : * mut LLMQSnapshot_FFI , pub snapshot_at_h_3c : * mut LLMQSnapshot_FFI , pub snapshot_at_h_4c : * mut LLMQSnapshot_FFI , pub extra_share : bool , pub last_quorum_per_index : * mut Vec_crate_models_llmq_entry_LLMQEntry_FFI , pub quorum_snapshot_list : * mut Vec_crate_models_snapshot_LLMQSnapshot_FFI , pub mn_list_diff_list : * mut Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI , } impl ferment_interfaces :: FFIConversion < QRInfoResult > for QRInfoResult_FFI { unsafe fn ffi_from_const (ffi : * const QRInfoResult_FFI) -> QRInfoResult { let ffi_ref = & * ffi ; QRInfoResult { result_at_tip : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . result_at_tip) , result_at_h : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . result_at_h) , result_at_h_c : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . result_at_h_c) , result_at_h_2c : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . result_at_h_2c) , result_at_h_3c : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . result_at_h_3c) , result_at_h_4c : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . result_at_h_4c) , snapshot_at_h_c : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . snapshot_at_h_c) , snapshot_at_h_2c : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . snapshot_at_h_2c) , snapshot_at_h_3c : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . snapshot_at_h_3c) , snapshot_at_h_4c : ferment_interfaces :: FFIConversion :: ffi_from_opt (ffi_ref . snapshot_at_h_4c) , extra_share : ffi_ref . extra_share , last_quorum_per_index : { let vec = & * ffi_ref . last_quorum_per_index ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , quorum_snapshot_list : { let vec = & * ffi_ref . quorum_snapshot_list ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , mn_list_diff_list : { let vec = & * ffi_ref . mn_list_diff_list ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , } } unsafe fn ffi_to_const (obj : QRInfoResult) -> * const QRInfoResult_FFI { ferment_interfaces :: boxed (QRInfoResult_FFI { result_at_tip : ferment_interfaces :: FFIConversion :: ffi_to (obj . result_at_tip) , result_at_h : ferment_interfaces :: FFIConversion :: ffi_to (obj . result_at_h) , result_at_h_c : ferment_interfaces :: FFIConversion :: ffi_to (obj . result_at_h_c) , result_at_h_2c : ferment_interfaces :: FFIConversion :: ffi_to (obj . result_at_h_2c) , result_at_h_3c : ferment_interfaces :: FFIConversion :: ffi_to (obj . result_at_h_3c) , result_at_h_4c : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . result_at_h_4c) , snapshot_at_h_c : ferment_interfaces :: FFIConversion :: ffi_to (obj . snapshot_at_h_c) , snapshot_at_h_2c : ferment_interfaces :: FFIConversion :: ffi_to (obj . snapshot_at_h_2c) , snapshot_at_h_3c : ferment_interfaces :: FFIConversion :: ffi_to (obj . snapshot_at_h_3c) , snapshot_at_h_4c : ferment_interfaces :: FFIConversion :: ffi_to_opt (obj . snapshot_at_h_4c) , extra_share : obj . extra_share , last_quorum_per_index : ferment_interfaces :: FFIConversion :: ffi_to (obj . last_quorum_per_index) , quorum_snapshot_list : ferment_interfaces :: FFIConversion :: ffi_to (obj . quorum_snapshot_list) , mn_list_diff_list : ferment_interfaces :: FFIConversion :: ffi_to (obj . mn_list_diff_list) , }) } unsafe fn destroy (ffi : * mut QRInfoResult_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for QRInfoResult_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < MNListDiffResult_FFI as ferment_interfaces :: FFIConversion < MNListDiffResult >> :: destroy (ffi_ref . result_at_tip) ; < MNListDiffResult_FFI as ferment_interfaces :: FFIConversion < MNListDiffResult >> :: destroy (ffi_ref . result_at_h) ; < MNListDiffResult_FFI as ferment_interfaces :: FFIConversion < MNListDiffResult >> :: destroy (ffi_ref . result_at_h_c) ; < MNListDiffResult_FFI as ferment_interfaces :: FFIConversion < MNListDiffResult >> :: destroy (ffi_ref . result_at_h_2c) ; < MNListDiffResult_FFI as ferment_interfaces :: FFIConversion < MNListDiffResult >> :: destroy (ffi_ref . result_at_h_3c) ; if ! ffi_ref . result_at_h_4c . is_null () { ferment_interfaces :: unbox_any (ffi_ref . result_at_h_4c) ; } ; < LLMQSnapshot_FFI as ferment_interfaces :: FFIConversion < LLMQSnapshot >> :: destroy (ffi_ref . snapshot_at_h_c) ; < LLMQSnapshot_FFI as ferment_interfaces :: FFIConversion < LLMQSnapshot >> :: destroy (ffi_ref . snapshot_at_h_2c) ; < LLMQSnapshot_FFI as ferment_interfaces :: FFIConversion < LLMQSnapshot >> :: destroy (ffi_ref . snapshot_at_h_3c) ; if ! ffi_ref . snapshot_at_h_4c . is_null () { ferment_interfaces :: unbox_any (ffi_ref . snapshot_at_h_4c) ; } ; { } ; ferment_interfaces :: unbox_any (ffi_ref . last_quorum_per_index) ; ; ferment_interfaces :: unbox_any (ffi_ref . quorum_snapshot_list) ; ; ferment_interfaces :: unbox_any (ffi_ref . mn_list_diff_list) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn QRInfoResult_FFI_destroy (ffi : * mut QRInfoResult_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } pub mod mn_listdiff_result { use crate :: models :: masternode_entry :: MasternodeEntry ; use crate :: models :: llmq_entry :: LLMQEntry ; use crate :: crypto :: UInt256 ; use crate :: models :: masternode_list :: MasternodeList ; use crate :: processing :: mn_listdiff_result :: MNListDiffResult ; use crate :: fermented :: types :: models :: masternode_entry :: MasternodeEntry_FFI ; use crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI ; use crate :: fermented :: types :: models :: masternode_list :: MasternodeList_FFI ; use std :: collections :: BTreeMap ; use crate :: fermented :: generics :: Vec_crate_models_llmq_entry_LLMQEntry_FFI ; use crate :: fermented :: generics :: std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI ; use crate :: fermented :: generics :: Vec_crate_crypto_UInt256_FFI ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the MNListDiffResult\"]"] # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct MNListDiffResult_FFI { pub base_block_hash : * mut [u8 ; 32] , pub block_hash : * mut [u8 ; 32] , pub has_found_coinbase : bool , pub has_valid_coinbase : bool , pub has_valid_mn_list_root : bool , pub has_valid_llmq_list_root : bool , pub has_valid_quorums : bool , pub masternode_list : * mut MasternodeList_FFI , pub added_masternodes : * mut std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI , pub modified_masternodes : * mut std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI , pub added_quorums : * mut Vec_crate_models_llmq_entry_LLMQEntry_FFI , pub needed_masternode_lists : * mut Vec_crate_crypto_UInt256_FFI , } impl ferment_interfaces :: FFIConversion < MNListDiffResult > for MNListDiffResult_FFI { unsafe fn ffi_from_const (ffi : * const MNListDiffResult_FFI) -> MNListDiffResult { let ffi_ref = & * ffi ; MNListDiffResult { base_block_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . base_block_hash) , block_hash : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . block_hash) , has_found_coinbase : ffi_ref . has_found_coinbase , has_valid_coinbase : ffi_ref . has_valid_coinbase , has_valid_mn_list_root : ffi_ref . has_valid_mn_list_root , has_valid_llmq_list_root : ffi_ref . has_valid_llmq_list_root , has_valid_quorums : ffi_ref . has_valid_quorums , masternode_list : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . masternode_list) , added_masternodes : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . added_masternodes) , modified_masternodes : ferment_interfaces :: FFIConversion :: ffi_from (ffi_ref . modified_masternodes) , added_quorums : { let vec = & * ffi_ref . added_quorums ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , needed_masternode_lists : { let vec = & * ffi_ref . needed_masternode_lists ; ferment_interfaces :: from_complex_vec (vec . values , vec . count) } , } } unsafe fn ffi_to_const (obj : MNListDiffResult) -> * const MNListDiffResult_FFI { ferment_interfaces :: boxed (MNListDiffResult_FFI { base_block_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . base_block_hash) , block_hash : ferment_interfaces :: FFIConversion :: ffi_to (obj . block_hash) , has_found_coinbase : obj . has_found_coinbase , has_valid_coinbase : obj . has_valid_coinbase , has_valid_mn_list_root : obj . has_valid_mn_list_root , has_valid_llmq_list_root : obj . has_valid_llmq_list_root , has_valid_quorums : obj . has_valid_quorums , masternode_list : ferment_interfaces :: FFIConversion :: ffi_to (obj . masternode_list) , added_masternodes : ferment_interfaces :: FFIConversion :: ffi_to (obj . added_masternodes) , modified_masternodes : ferment_interfaces :: FFIConversion :: ffi_to (obj . modified_masternodes) , added_quorums : ferment_interfaces :: FFIConversion :: ffi_to (obj . added_quorums) , needed_masternode_lists : ferment_interfaces :: FFIConversion :: ffi_to (obj . needed_masternode_lists) , }) } unsafe fn destroy (ffi : * mut MNListDiffResult_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for MNListDiffResult_FFI { fn drop (& mut self) { unsafe { let ffi_ref = self ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . base_block_hash) ; < [u8 ; 32] as ferment_interfaces :: FFIConversion < UInt256 >> :: destroy (ffi_ref . block_hash) ; { } ; { } ; { } ; { } ; { } ; < MasternodeList_FFI as ferment_interfaces :: FFIConversion < MasternodeList >> :: destroy (ffi_ref . masternode_list) ; ferment_interfaces :: unbox_any (ffi_ref . added_masternodes) ; ; ferment_interfaces :: unbox_any (ffi_ref . modified_masternodes) ; ; ferment_interfaces :: unbox_any (ffi_ref . added_quorums) ; ; ferment_interfaces :: unbox_any (ffi_ref . needed_masternode_lists) ; ; } } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn MNListDiffResult_FFI_destroy (ffi : * mut MNListDiffResult_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } } pub mod crypto { pub mod byte_util { use crate :: crypto :: byte_util :: UInt160 ; use crate :: crypto :: byte_util :: UInt512 ; use crate :: crypto :: byte_util :: UInt128 ; use crate :: crypto :: byte_util :: UInt384 ; use crate :: crypto :: byte_util :: UInt256 ; use crate :: crypto :: byte_util :: UInt768 ; # [doc = "FFI-representation of the # [doc = \"FFI-representation of the UInt768\"]"] impl ferment_interfaces :: FFIConversion < UInt768 > for [u8 ; 96] { unsafe fn ffi_from_const (ffi : * const [u8 ; 96]) -> UInt768 { let ffi_ref = * ffi ; UInt768 (ffi_ref ,) } unsafe fn ffi_to_const (obj : UInt768) -> * const [u8 ; 96] { ferment_interfaces :: boxed (obj . 0) } unsafe fn destroy (ffi : * mut [u8 ; 96]) { ; } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UInt768_FFI_destroy (ffi : * mut [u8 ; 96]) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the UInt256\"]"] impl ferment_interfaces :: FFIConversion < UInt256 > for [u8 ; 32] { unsafe fn ffi_from_const (ffi : * const [u8 ; 32]) -> UInt256 { let ffi_ref = * ffi ; UInt256 (ffi_ref ,) } unsafe fn ffi_to_const (obj : UInt256) -> * const [u8 ; 32] { ferment_interfaces :: boxed (obj . 0) } unsafe fn destroy (ffi : * mut [u8 ; 32]) { ; } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UInt256_FFI_destroy (ffi : * mut [u8 ; 32]) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the UInt384\"]"] impl ferment_interfaces :: FFIConversion < UInt384 > for [u8 ; 48] { unsafe fn ffi_from_const (ffi : * const [u8 ; 48]) -> UInt384 { let ffi_ref = * ffi ; UInt384 (ffi_ref ,) } unsafe fn ffi_to_const (obj : UInt384) -> * const [u8 ; 48] { ferment_interfaces :: boxed (obj . 0) } unsafe fn destroy (ffi : * mut [u8 ; 48]) { ; } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UInt384_FFI_destroy (ffi : * mut [u8 ; 48]) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the UInt512\"]"] impl ferment_interfaces :: FFIConversion < UInt512 > for [u8 ; 64] { unsafe fn ffi_from_const (ffi : * const [u8 ; 64]) -> UInt512 { let ffi_ref = * ffi ; UInt512 (ffi_ref ,) } unsafe fn ffi_to_const (obj : UInt512) -> * const [u8 ; 64] { ferment_interfaces :: boxed (obj . 0) } unsafe fn destroy (ffi : * mut [u8 ; 64]) { ; } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UInt512_FFI_destroy (ffi : * mut [u8 ; 64]) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the UInt160\"]"] impl ferment_interfaces :: FFIConversion < UInt160 > for [u8 ; 20] { unsafe fn ffi_from_const (ffi : * const [u8 ; 20]) -> UInt160 { let ffi_ref = * ffi ; UInt160 (ffi_ref ,) } unsafe fn ffi_to_const (obj : UInt160) -> * const [u8 ; 20] { ferment_interfaces :: boxed (obj . 0) } unsafe fn destroy (ffi : * mut [u8 ; 20]) { ; } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UInt160_FFI_destroy (ffi : * mut [u8 ; 20]) { ferment_interfaces :: unbox_any (ffi) ; } # [doc = "FFI-representation of the # [doc = \"FFI-representation of the UInt128\"]"] impl ferment_interfaces :: FFIConversion < UInt128 > for [u8 ; 16] { unsafe fn ffi_from_const (ffi : * const [u8 ; 16]) -> UInt128 { let ffi_ref = * ffi ; UInt128 (ffi_ref ,) } unsafe fn ffi_to_const (obj : UInt128) -> * const [u8 ; 16] { ferment_interfaces :: boxed (obj . 0) } unsafe fn destroy (ffi : * mut [u8 ; 16]) { ; } } # [doc = r" # Safety"] # [allow (non_snake_case)] # [no_mangle] pub unsafe extern "C" fn UInt128_FFI_destroy (ffi : * mut [u8 ; 16]) { ferment_interfaces :: unbox_any (ffi) ; } } } } # [allow (clippy :: let_and_return , clippy :: redundant_field_names , dead_code , redundant_semicolons , unused_braces , unused_imports , unused_unsafe , unused_variables)] pub mod generics { # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: chain :: common :: llmq_type :: LLMQType_FFI , pub values : * mut * mut std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: chain :: common :: llmq_type :: LLMQType , std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry > > > for std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI) -> std :: collections :: BTreeMap < crate :: chain :: common :: llmq_type :: LLMQType , std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry > > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: chain :: common :: llmq_type :: LLMQType , std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry > >) -> * const std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: chain :: common :: llmq_type :: LLMQType , crate :: fermented :: types :: chain :: common :: llmq_type :: LLMQType_FFI > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry > , std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_chain_common_llmq_type_LLMQType_values_std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_tx_transaction_TransactionInput_FFI { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: tx :: transaction :: TransactionInput_FFI , } impl ferment_interfaces :: FFIConversion < Vec < crate :: tx :: transaction :: TransactionInput >> for Vec_crate_tx_transaction_TransactionInput_FFI { unsafe fn ffi_from_const (ffi : * const Vec_crate_tx_transaction_TransactionInput_FFI) -> Vec < crate :: tx :: transaction :: TransactionInput > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: tx :: transaction :: TransactionInput >) -> * const Vec_crate_tx_transaction_TransactionInput_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_tx_transaction_TransactionInput_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_tx_transaction_TransactionInput_FFI { type Value = crate :: tx :: transaction :: TransactionInput ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: types :: tx :: transaction :: TransactionInput_FFI > (obj . into_iter ()) }) } } impl Drop for Vec_crate_tx_transaction_TransactionInput_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_crypto_UInt256_FFI { pub count : usize , pub values : * mut * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < Vec < crate :: crypto :: UInt256 >> for Vec_crate_crypto_UInt256_FFI { unsafe fn ffi_from_const (ffi : * const Vec_crate_crypto_UInt256_FFI) -> Vec < crate :: crypto :: UInt256 > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: crypto :: UInt256 >) -> * const Vec_crate_crypto_UInt256_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_crypto_UInt256_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_crypto_UInt256_FFI { type Value = crate :: crypto :: UInt256 ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , [u8 ; 32] > (obj . into_iter ()) }) } } impl Drop for Vec_crate_crypto_UInt256_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: processing :: mn_listdiff_result :: MNListDiffResult_FFI , } impl ferment_interfaces :: FFIConversion < Vec < crate :: processing :: mn_listdiff_result :: MNListDiffResult >> for Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI { unsafe fn ffi_from_const (ffi : * const Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI) -> Vec < crate :: processing :: mn_listdiff_result :: MNListDiffResult > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: processing :: mn_listdiff_result :: MNListDiffResult >) -> * const Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI { type Value = crate :: processing :: mn_listdiff_result :: MNListDiffResult ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: types :: processing :: mn_listdiff_result :: MNListDiffResult_FFI > (obj . into_iter ()) }) } } impl Drop for Vec_crate_processing_mn_listdiff_result_MNListDiffResult_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_common_block_Block_values_bool_FFI { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: common :: block :: Block_FFI , pub values : * mut bool , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: common :: block :: Block , bool > > for std_collections_Map_keys_crate_common_block_Block_values_bool_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_common_block_Block_values_bool_FFI) -> std :: collections :: BTreeMap < crate :: common :: block :: Block , bool > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_simple_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: common :: block :: Block , bool >) -> * const std_collections_Map_keys_crate_common_block_Block_values_bool_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: common :: block :: Block , crate :: fermented :: types :: common :: block :: Block_FFI > (obj . keys () . cloned ()) , values : ferment_interfaces :: to_simple_vec (obj . values () . cloned () . collect :: < Vec < _ >> ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_common_block_Block_values_bool_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_common_block_Block_values_bool_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_i32_FFI { pub count : usize , pub values : * mut i32 , } impl ferment_interfaces :: FFIConversion < Vec < i32 >> for Vec_i32_FFI { unsafe fn ffi_from_const (ffi : * const Vec_i32_FFI) -> Vec < i32 > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < i32 >) -> * const Vec_i32_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_i32_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_i32_FFI { type Value = i32 ; unsafe fn decode (& self) -> Vec < Self :: Value > { ferment_interfaces :: from_simple_vec (self . values as * const Self :: Value , self . count) } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_i32_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_u8_FFI { pub count : usize , pub values : * mut u8 , } impl ferment_interfaces :: FFIConversion < Vec < u8 >> for Vec_u8_FFI { unsafe fn ffi_from_const (ffi : * const Vec_u8_FFI) -> Vec < u8 > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < u8 >) -> * const Vec_u8_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_u8_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_u8_FFI { type Value = u8 ; unsafe fn decode (& self) -> Vec < Self :: Value > { ferment_interfaces :: from_simple_vec (self . values as * const Self :: Value , self . count) } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: boxed_vec (obj) }) } } impl Drop for Vec_u8_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI { pub count : usize , pub keys : * mut * mut [u8 ; 32] , pub values : * mut * mut crate :: fermented :: types :: models :: masternode_entry :: MasternodeEntry_FFI , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: masternode_entry :: MasternodeEntry > > for std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI) -> std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: masternode_entry :: MasternodeEntry > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: masternode_entry :: MasternodeEntry >) -> * const std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: crypto :: UInt256 , [u8 ; 32] > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: models :: masternode_entry :: MasternodeEntry , crate :: fermented :: types :: models :: masternode_entry :: MasternodeEntry_FFI > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_masternode_entry_MasternodeEntry_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_tx_transaction_TransactionOutput_FFI { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: tx :: transaction :: TransactionOutput_FFI , } impl ferment_interfaces :: FFIConversion < Vec < crate :: tx :: transaction :: TransactionOutput >> for Vec_crate_tx_transaction_TransactionOutput_FFI { unsafe fn ffi_from_const (ffi : * const Vec_crate_tx_transaction_TransactionOutput_FFI) -> Vec < crate :: tx :: transaction :: TransactionOutput > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: tx :: transaction :: TransactionOutput >) -> * const Vec_crate_tx_transaction_TransactionOutput_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_tx_transaction_TransactionOutput_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_tx_transaction_TransactionOutput_FFI { type Value = crate :: tx :: transaction :: TransactionOutput ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: types :: tx :: transaction :: TransactionOutput_FFI > (obj . into_iter ()) }) } } impl Drop for Vec_crate_tx_transaction_TransactionOutput_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: common :: block :: Block_FFI , pub values : * mut * mut crate :: fermented :: types :: models :: operator_public_key :: OperatorPublicKey_FFI , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: common :: block :: Block , crate :: models :: operator_public_key :: OperatorPublicKey > > for std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI) -> std :: collections :: BTreeMap < crate :: common :: block :: Block , crate :: models :: operator_public_key :: OperatorPublicKey > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: common :: block :: Block , crate :: models :: operator_public_key :: OperatorPublicKey >) -> * const std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: common :: block :: Block , crate :: fermented :: types :: common :: block :: Block_FFI > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: models :: operator_public_key :: OperatorPublicKey , crate :: fermented :: types :: models :: operator_public_key :: OperatorPublicKey_FFI > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_common_block_Block_values_crate_models_operator_public_key_OperatorPublicKey_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_models_llmq_entry_LLMQEntry_FFI { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI , } impl ferment_interfaces :: FFIConversion < Vec < crate :: models :: llmq_entry :: LLMQEntry >> for Vec_crate_models_llmq_entry_LLMQEntry_FFI { unsafe fn ffi_from_const (ffi : * const Vec_crate_models_llmq_entry_LLMQEntry_FFI) -> Vec < crate :: models :: llmq_entry :: LLMQEntry > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: models :: llmq_entry :: LLMQEntry >) -> * const Vec_crate_models_llmq_entry_LLMQEntry_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_models_llmq_entry_LLMQEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_models_llmq_entry_LLMQEntry_FFI { type Value = crate :: models :: llmq_entry :: LLMQEntry ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI > (obj . into_iter ()) }) } } impl Drop for Vec_crate_models_llmq_entry_LLMQEntry_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct Vec_crate_models_snapshot_LLMQSnapshot_FFI { pub count : usize , pub values : * mut * mut crate :: fermented :: types :: models :: snapshot :: LLMQSnapshot_FFI , } impl ferment_interfaces :: FFIConversion < Vec < crate :: models :: snapshot :: LLMQSnapshot >> for Vec_crate_models_snapshot_LLMQSnapshot_FFI { unsafe fn ffi_from_const (ffi : * const Vec_crate_models_snapshot_LLMQSnapshot_FFI) -> Vec < crate :: models :: snapshot :: LLMQSnapshot > { let ffi_ref = & * ffi ; ferment_interfaces :: FFIVecConversion :: decode (ffi_ref) } unsafe fn ffi_to_const (obj : Vec < crate :: models :: snapshot :: LLMQSnapshot >) -> * const Vec_crate_models_snapshot_LLMQSnapshot_FFI { ferment_interfaces :: FFIVecConversion :: encode (obj) } unsafe fn destroy (ffi : * mut Vec_crate_models_snapshot_LLMQSnapshot_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl ferment_interfaces :: FFIVecConversion for Vec_crate_models_snapshot_LLMQSnapshot_FFI { type Value = crate :: models :: snapshot :: LLMQSnapshot ; unsafe fn decode (& self) -> Vec < Self :: Value > { { let count = self . count ; let values = self . values ; (0 .. count) . map (| i | ferment_interfaces :: FFIConversion :: ffi_from_const (* values . add (i))) . collect () } } unsafe fn encode (obj : Vec < Self :: Value >) -> * mut Self { ferment_interfaces :: boxed (Self { count : obj . len () , values : ferment_interfaces :: complex_vec_iterator :: < Self :: Value , crate :: fermented :: types :: models :: snapshot :: LLMQSnapshot_FFI > (obj . into_iter ()) }) } } impl Drop for Vec_crate_models_snapshot_LLMQSnapshot_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI { pub count : usize , pub keys : * mut * mut crate :: fermented :: types :: common :: block :: Block_FFI , pub values : * mut * mut [u8 ; 32] , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: common :: block :: Block , crate :: crypto :: UInt256 > > for std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI) -> std :: collections :: BTreeMap < crate :: common :: block :: Block , crate :: crypto :: UInt256 > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: common :: block :: Block , crate :: crypto :: UInt256 >) -> * const std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: common :: block :: Block , crate :: fermented :: types :: common :: block :: Block_FFI > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: crypto :: UInt256 , [u8 ; 32] > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_common_block_Block_values_crate_crypto_UInt256_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } # [repr (C)] # [derive (Clone)] # [allow (non_camel_case_types)] pub struct std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { pub count : usize , pub keys : * mut * mut [u8 ; 32] , pub values : * mut * mut crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI , } impl ferment_interfaces :: FFIConversion < std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry > > for std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { unsafe fn ffi_from_const (ffi : * const std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI) -> std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry > { let ffi_ref = & * ffi ; ferment_interfaces :: from_complex_map (ffi_ref . count , ffi_ref . keys , ffi_ref . values) } unsafe fn ffi_to_const (obj : std :: collections :: BTreeMap < crate :: crypto :: UInt256 , crate :: models :: llmq_entry :: LLMQEntry >) -> * const std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { ferment_interfaces :: boxed (Self { count : obj . len () , keys : ferment_interfaces :: complex_vec_iterator :: < crate :: crypto :: UInt256 , [u8 ; 32] > (obj . keys () . cloned ()) , values : ferment_interfaces :: complex_vec_iterator :: < crate :: models :: llmq_entry :: LLMQEntry , crate :: fermented :: types :: models :: llmq_entry :: LLMQEntry_FFI > (obj . values () . cloned ()) }) } unsafe fn destroy (ffi : * mut std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI) { ferment_interfaces :: unbox_any (ffi) ; } } impl Drop for std_collections_Map_keys_crate_crypto_UInt256_values_crate_models_llmq_entry_LLMQEntry_FFI { fn drop (& mut self) { unsafe { ferment_interfaces :: unbox_any_vec_ptr (self . keys , self . count) ; ferment_interfaces :: unbox_any_vec_ptr (self . values , self . count) ; } } } }